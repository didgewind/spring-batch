Proyecto sin maven spring batch complejo. Basado en el código de
Spring Batch in Action. El proceso consiste en la lectura de un fichero
con información sobre los productos de un catálogo y el paso de esa
información a una base de datos.

Versiones
=========

* Ch 01 - Lectura directa del txt, escritura en consola

Sólo hay un step que lee la info del fichero data/products.txt, no usa job parameters para especificar 
los inputs y los output y el output va a consola. El reader tiene un skip-limit y un 
elemento <skippable-exception-classes> que se puede comentar para ver cómo falla todo cuando 
hay un error en el fichero de entrada.

La clase que lo lanza todo es TestSCBatch. config/job-context.xml une los dos ficheros de
configuración, import-products-job-context.xml, que configura el job, y console-context.xml,
que configura la arquitectura (job launcher, repository, transaction manager, etc.).

Product es el modelo. ProductFieldSetMapper mapea los campos del fichero de datos al modelo,
ProductConsoleItemWriter se encarga de escribir la info en la consola.

* Ch 01 - Descomprensión de zip, escritura en consola

Como el anterior pero ahora hay un step previo para extraer el .txt de un fichero zip.
Organizamos mejor los ficheros de entrada (data/input) y los de salida (data/target).

DecompressTasklet es la tarea descompresora.

* Ch 01 (bien) - Descomprensión de zip, escritura en bd, no fallo en excepción de parseo (antes tampoco).

La salida es a una tabla en la bd. Usamos mysql-context.xml en vez de console-context.xml
para configurar la salida a la bd, y ProductJdbcItemWriter es el ItemWriter de bd.
bd/create-products-db.sql es el script de creación, e init-products-db.sql es un script
invocado por spring al lanzar la app (<jdbc:initialize-database> en mysql-context.xml) para
resetear la bd y dejar sólo un producto.

* Ch 02 - JobRepository en bd acme_catalog

El job repository está también en la bd. El script de creación de tablas está en el paquete
org.springframework.batch.core del jar de spring-batch-core, y lo hemos copiado a bd.

TestSCBatch cambia su parámetro timestamp para poder repetirlo y que el job lance una
excepción porque no se puede repetir un jobinstance con parámetros similares. Si cambiamos
el zip por products_corrupted.zip el trabajo no se lanza porque el archivo está corrupto.
ATENCIÓN: EN ESTE CASO ES IMPORTANTE QUE LA LIBRERÍA JETTISON SEA LA 1.1, Y NO LA 1.3.8,
COMO ESTABA EN ANTERIORES COMMITS

Se puede ver todo con la app spring batch admin (si llego a poder configurarla :) ).


* Empleados reader delimited

Tenemos un fichero de empleados en single line con campos delimitados por #,
que importamos en una tabla de la bd. Usamos un FlatFileItemReader
que se apoya en un DefaultLineMapper que se apoya a su vez
en un DelimitedLineTokenizer (para tokenizar cada campo de la línea) y en
un BeanWrapperFieldSetMapper (para generar el objeto Empleado a partir de 
esos campos).

Usamos un writer de Jdbc personalizado.

El job-context importa los xmls necesarios.


* Ch 05 - Products reader fixed length

Leemos de products-fixed.txt con un FixedLengthTokenizer en vez de un
DelimitedLineTokenizer

* Ch 05 - Products reader Json

Leemos de products.json con un JsonLineMapper encapsulado en una clase propia,
JSONWrapperMapper. Hay que usar un recordSeparatorPolicy específico para Json.

* Ch 05 - Products reader multiline

Leemos de un fichero con registros multilínea. Especificamos una política
de separación de registros personalizada (cuando leamos tres comas ya se ha
leído el registro)

* Ch 05 - Fichero con productos y empleados

Leemos de un fichero con registros Empleado y Producto. Ambas clases del modelo
implementan Item, que es un interfaz de marca al que hacemos referencia en el
writer (GenericItemWriter). Este writer delega a su vez en el writer correspondiente.

Para leer usamos un PatternMatchingCompositeLineMapper que delega en el tokenizer
correspondiente en función del comienzo de la línea (PR* si es un producto, cualquier
otra cosa si es un empleado)

* Ch 05 - Reader Productos Xml

El reader es un StaxEventItemReader, que se apoya en un unmarshaller CastorMarshaller
que utiliza a su vez mapping.xml para mapear el producto con el elemento <product> del
fichero .xml

* Ch 05 - Lectura de productos de bd

Leemos los productos de la bd mediante un JdbcCursorItemReader que se apoya en un
rowMapper personalizado, y usamos un writer personalizado (ProductConsoleItemWriter)
para mostrarlos en consola